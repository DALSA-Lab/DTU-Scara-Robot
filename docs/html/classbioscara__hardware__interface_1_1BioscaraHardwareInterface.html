<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bioscara: bioscara_hardware_interface::BioscaraHardwareInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="dtu_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Bioscara
   </div>
   <div id="projectbrief">DALSAs DIY SCARA robot arm.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebioscara__hardware__interface.html">bioscara_hardware_interface</a></li><li class="navelem"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html">BioscaraHardwareInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">bioscara_hardware_interface::BioscaraHardwareInterface Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The bioscara hardware interface class.  
 <a href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bioscara__hardware_8hpp_source.html">bioscara_hardware.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bioscara_hardware_interface::BioscaraHardwareInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classbioscara__hardware__interface_1_1BioscaraHardwareInterface__inherit__graph.png" border="0" usemap="#abioscara__hardware__interface_1_1BioscaraHardwareInterface_inherit__map" alt="Inheritance graph"/></div>
<map name="abioscara__hardware__interface_1_1BioscaraHardwareInterface_inherit__map" id="abioscara__hardware__interface_1_1BioscaraHardwareInterface_inherit__map">
<area shape="rect" title="The bioscara hardware interface class." alt="" coords="5,93,216,133"/>
<area shape="rect" title=" " alt="" coords="37,5,185,45"/>
<area shape="poly" title=" " alt="" coords="113,59,113,93,108,93,108,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for bioscara_hardware_interface::BioscaraHardwareInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classbioscara__hardware__interface_1_1BioscaraHardwareInterface__coll__graph.png" border="0" usemap="#abioscara__hardware__interface_1_1BioscaraHardwareInterface_coll__map" alt="Collaboration graph"/></div>
<map name="abioscara__hardware__interface_1_1BioscaraHardwareInterface_coll__map" id="abioscara__hardware__interface_1_1BioscaraHardwareInterface_coll__map">
<area shape="rect" title="The bioscara hardware interface class." alt="" coords="5,93,216,133"/>
<area shape="rect" title=" " alt="" coords="37,5,185,45"/>
<area shape="poly" title=" " alt="" coords="113,59,113,93,108,93,108,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbioscara__hardware__interface_1_1BioscaraHardwareInterface_1_1joint__config__t.html">joint_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">configuration structure holding the passed paramters from the ros2_control urdf  <a href="structbioscara__hardware__interface_1_1BioscaraHardwareInterface_1_1joint__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbioscara__hardware__interface_1_1BioscaraHardwareInterface_1_1joint__homing__config__t.html">joint_homing_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">configuration structure holding the passed homing paramters from the ros2_control urdf  <a href="structbioscara__hardware__interface_1_1BioscaraHardwareInterface_1_1joint__homing__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6aa90281abb9010d645ee5b0d5144af6" id="r_a6aa90281abb9010d645ee5b0d5144af6"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a6aa90281abb9010d645ee5b0d5144af6">on_init</a> (const hardware_interface::HardwareComponentInterfaceParams &amp;params) override</td></tr>
<tr class="memdesc:a6aa90281abb9010d645ee5b0d5144af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called on initialization to the <code>unconfigured</code> state.  <br /></td></tr>
<tr class="separator:a6aa90281abb9010d645ee5b0d5144af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b03c347e879fa429abec6a717f24e9" id="r_af6b03c347e879fa429abec6a717f24e9"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#af6b03c347e879fa429abec6a717f24e9">on_shutdown</a> (const rclcpp_lifecycle::State &amp;previous_state) override</td></tr>
<tr class="memdesc:af6b03c347e879fa429abec6a717f24e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called on the transistion from the <code>inactive</code>, <code>unconfigured</code> and <code>active</code> to the <code>finalized</code> state.  <br /></td></tr>
<tr class="separator:af6b03c347e879fa429abec6a717f24e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae274309914b709c3e7fea6bc20864050" id="r_ae274309914b709c3e7fea6bc20864050"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#ae274309914b709c3e7fea6bc20864050">on_configure</a> (const rclcpp_lifecycle::State &amp;previous_state) override</td></tr>
<tr class="memdesc:ae274309914b709c3e7fea6bc20864050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called on the transistion from the <code>unconfigured</code> to the <code>inactive</code> state.  <br /></td></tr>
<tr class="separator:ae274309914b709c3e7fea6bc20864050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113dab971a250a727d68a0aef28c13e6" id="r_a113dab971a250a727d68a0aef28c13e6"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a113dab971a250a727d68a0aef28c13e6">on_cleanup</a> (const rclcpp_lifecycle::State &amp;previous_state) override</td></tr>
<tr class="memdesc:a113dab971a250a727d68a0aef28c13e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called on the transistion from the <code>inactive</code> to the <code>unconfigured</code> state.  <br /></td></tr>
<tr class="separator:a113dab971a250a727d68a0aef28c13e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1af9ab693e0a0dad30bac75bc02b462" id="r_ad1af9ab693e0a0dad30bac75bc02b462"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#ad1af9ab693e0a0dad30bac75bc02b462">on_activate</a> (const rclcpp_lifecycle::State &amp;previous_state) override</td></tr>
<tr class="memdesc:ad1af9ab693e0a0dad30bac75bc02b462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called on the transistion from the <code>inactive</code> to the <code>active</code> state.  <br /></td></tr>
<tr class="separator:ad1af9ab693e0a0dad30bac75bc02b462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3a7dd7cbf651783175b5766c8220c8" id="r_aec3a7dd7cbf651783175b5766c8220c8"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#aec3a7dd7cbf651783175b5766c8220c8">on_deactivate</a> (const rclcpp_lifecycle::State &amp;previous_state) override</td></tr>
<tr class="memdesc:aec3a7dd7cbf651783175b5766c8220c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called on the transistion from the <code>active</code> to the <code>inactive</code> state.  <br /></td></tr>
<tr class="separator:aec3a7dd7cbf651783175b5766c8220c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6356a580850582282adf77e9461a40" id="r_afd6356a580850582282adf77e9461a40"><td class="memItemLeft" align="right" valign="top">hardware_interface::return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#afd6356a580850582282adf77e9461a40">read</a> (const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period) override</td></tr>
<tr class="memdesc:afd6356a580850582282adf77e9461a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads from the hardware and populates the state interfaces.  <br /></td></tr>
<tr class="separator:afd6356a580850582282adf77e9461a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababed9c7c6dc8660f20dc1b4e950c023" id="r_ababed9c7c6dc8660f20dc1b4e950c023"><td class="memItemLeft" align="right" valign="top">hardware_interface::return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#ababed9c7c6dc8660f20dc1b4e950c023">write</a> (const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period) override</td></tr>
<tr class="memdesc:ababed9c7c6dc8660f20dc1b4e950c023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes commands to the hardware from the command interfaces.  <br /></td></tr>
<tr class="separator:ababed9c7c6dc8660f20dc1b4e950c023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae217264240bb140ca85381c0d1ca24e4" id="r_ae217264240bb140ca85381c0d1ca24e4"><td class="memItemLeft" align="right" valign="top">hardware_interface::return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#ae217264240bb140ca85381c0d1ca24e4">prepare_command_mode_switch</a> (const std::vector&lt; std::string &gt; &amp;start_interfaces, const std::vector&lt; std::string &gt; &amp;stop_interfaces) override</td></tr>
<tr class="memdesc:ae217264240bb140ca85381c0d1ca24e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs checks and book keeping of the active control mode when changing controllers.  <br /></td></tr>
<tr class="separator:ae217264240bb140ca85381c0d1ca24e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22b95903e65936fdcfdd889074adefd" id="r_ab22b95903e65936fdcfdd889074adefd"><td class="memItemLeft" align="right" valign="top">hardware_interface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#ab22b95903e65936fdcfdd889074adefd">on_error</a> (const rclcpp_lifecycle::State &amp;previous_state) override</td></tr>
<tr class="memdesc:ab22b95903e65936fdcfdd889074adefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error in any state or state transition is thrown.  <br /></td></tr>
<tr class="separator:ab22b95903e65936fdcfdd889074adefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aceb1efdc164d5c79540f117bf6320bcd" id="r_aceb1efdc164d5c79540f117bf6320bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebioscara__hardware__driver.html#afd669880becd2fc4859d33a0f7780231">bioscara_hardware_driver::err_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#aceb1efdc164d5c79540f117bf6320bcd">start_homing</a> (const std::string name, float velocity)</td></tr>
<tr class="memdesc:aceb1efdc164d5c79540f117bf6320bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:aceb1efdc164d5c79540f117bf6320bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edae840470034cfff21117b3270d4f5" id="r_a1edae840470034cfff21117b3270d4f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacebioscara__hardware__driver.html#afd669880becd2fc4859d33a0f7780231">bioscara_hardware_driver::err_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a1edae840470034cfff21117b3270d4f5">stop_homing</a> (const std::string name)</td></tr>
<tr class="memdesc:a1edae840470034cfff21117b3270d4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO.  <br /></td></tr>
<tr class="separator:a1edae840470034cfff21117b3270d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8cf66b54b657b09db178d26e334ed3f5" id="r_a8cf66b54b657b09db178d26e334ed3f5"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::unique_ptr&lt; <a class="el" href="classbioscara__hardware__driver_1_1BaseJoint.html">bioscara_hardware_driver::BaseJoint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a8cf66b54b657b09db178d26e334ed3f5">_joints</a></td></tr>
<tr class="memdesc:a8cf66b54b657b09db178d26e334ed3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">unordered map storing the pointers to BaseJoint objects. This will either be a MockJoint or Joint.  <br /></td></tr>
<tr class="separator:a8cf66b54b657b09db178d26e334ed3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af71c4da340c7798ee83f1fcccc1979" id="r_a8af71c4da340c7798ee83f1fcccc1979"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="structbioscara__hardware__interface_1_1BioscaraHardwareInterface_1_1joint__config__t.html">joint_config_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a8af71c4da340c7798ee83f1fcccc1979">_joint_cfg</a></td></tr>
<tr class="memdesc:a8af71c4da340c7798ee83f1fcccc1979"><td class="mdescLeft">&#160;</td><td class="mdescRight">unordered map storing the configuration struct of the joints.  <br /></td></tr>
<tr class="separator:a8af71c4da340c7798ee83f1fcccc1979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1359775a2b4cfdaa48b41088b10adedb" id="r_a1359775a2b4cfdaa48b41088b10adedb"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::set&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a1359775a2b4cfdaa48b41088b10adedb">_joint_command_modes</a></td></tr>
<tr class="memdesc:a1359775a2b4cfdaa48b41088b10adedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">unordered map of sets storing the active command interfaces for each joint.  <br /></td></tr>
<tr class="separator:a1359775a2b4cfdaa48b41088b10adedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The bioscara hardware interface class. </p>
<p>The hardware interface serves to wrap custom hardware interaction in the standardized ros2_control architecture.</p>
<p><b>Hardware Lifecycle</b> <br  />
The hardware follows the ros2_control hardware interface lifecyle which intern is following the <a href="https://github.com/ros2/design/blob/93a415bf928751d37fce6f83215c521658e20c93/articles/node_lifecycle.md">ROS2 managed node lifecycle</a>.</p>
<div class="image">
<img src="hardware_interface_lifecycle.png" alt="" width="1000em"/>
<div class="caption">
Hardware interface lifecycle</div></div>
  </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad1af9ab693e0a0dad30bac75bc02b462" name="ad1af9ab693e0a0dad30bac75bc02b462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1af9ab693e0a0dad30bac75bc02b462">&#9670;&#160;</a></span>on_activate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn bioscara_hardware_interface::BioscaraHardwareInterface::on_activate </td>
          <td>(</td>
          <td class="paramtype">const rclcpp_lifecycle::State &amp;&#160;</td>
          <td class="paramname"><em>previous_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called on the transistion from the <code>inactive</code> to the <code>active</code> state. </p>
<p>Enables each joint, enables the stall detection and sets the maximmum acceleration. <br  />
It is allowed to activate the hardware even if it is not homed. To home the joint the homing_controller must be activated, but generally a hardware component must be active in order for controllers to become active. <br  />
 To prohibit movement on activation the set point for each position command interface is set equal to the current measured position, and the velocity command is set to 0.0 for each command interface. The current values are obtained by calling the <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#afd6356a580850582282adf77e9461a40" title="Reads from the hardware and populates the state interfaces.">read()</a> method once which populates the state interfaces with values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_state</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn </dd></dl>
<p>Below a workaround to force a read cycle of all joints to get inital values for the state interfaces. These will be copied to the command interface to prevent movement at startup.</p>

</div>
</div>
<a id="a113dab971a250a727d68a0aef28c13e6" name="a113dab971a250a727d68a0aef28c13e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113dab971a250a727d68a0aef28c13e6">&#9670;&#160;</a></span>on_cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn bioscara_hardware_interface::BioscaraHardwareInterface::on_cleanup </td>
          <td>(</td>
          <td class="paramtype">const rclcpp_lifecycle::State &amp;&#160;</td>
          <td class="paramname"><em>previous_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called on the transistion from the <code>inactive</code> to the <code>unconfigured</code> state. </p>
<p>Disconnect from the joints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_state</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn </dd></dl>
<p>Disconnect from the joints and throw error if it fails</p>

</div>
</div>
<a id="ae274309914b709c3e7fea6bc20864050" name="ae274309914b709c3e7fea6bc20864050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae274309914b709c3e7fea6bc20864050">&#9670;&#160;</a></span>on_configure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn bioscara_hardware_interface::BioscaraHardwareInterface::on_configure </td>
          <td>(</td>
          <td class="paramtype">const rclcpp_lifecycle::State &amp;&#160;</td>
          <td class="paramname"><em>previous_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called on the transistion from the <code>unconfigured</code> to the <code>inactive</code> state. </p>
<p>Establish and test connection to each joint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_state</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn </dd></dl>

</div>
</div>
<a id="aec3a7dd7cbf651783175b5766c8220c8" name="aec3a7dd7cbf651783175b5766c8220c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3a7dd7cbf651783175b5766c8220c8">&#9670;&#160;</a></span>on_deactivate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn bioscara_hardware_interface::BioscaraHardwareInterface::on_deactivate </td>
          <td>(</td>
          <td class="paramtype">const rclcpp_lifecycle::State &amp;&#160;</td>
          <td class="paramname"><em>previous_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called on the transistion from the <code>active</code> to the <code>inactive</code> state. </p>
<p>Disables all joints and thereby allows backdriving. State interfaces continue to be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_state</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn </dd></dl>
<p>disable the joints and throw error if it fails</p>

</div>
</div>
<a id="ab22b95903e65936fdcfdd889074adefd" name="ab22b95903e65936fdcfdd889074adefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22b95903e65936fdcfdd889074adefd">&#9670;&#160;</a></span>on_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn bioscara_hardware_interface::BioscaraHardwareInterface::on_error </td>
          <td>(</td>
          <td class="paramtype">const rclcpp_lifecycle::State &amp;&#160;</td>
          <td class="paramname"><em>previous_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an error in any state or state transition is thrown. </p>
<p>According to the <a href="https://control.ros.org/jazzy/doc/ros2_control/hardware_interface/doc/hardware_components_userdoc.html#handling-of-errors-that-happen-during-read-and-write-calls">ros2_control documentation</a>:</p>
<blockquote class="doxtable">
<p>&zwj;Error handling follows the node lifecycle. If successful CallbackReturn::SUCCESS is returned and hardware is again in <code>UNCONFIGURED</code> state, if any ERROR or FAILURE happens the hardware ends in <code>FINALIZED</code> state and can not be recovered. The only option is to reload the complete plugin, but there is currently no service for this in the Controller Manager. </p>
</blockquote>
<p>Since the hardware will immediatly return to the <code>unconfigured</code> state (<a href="https://github.com/ros-controls/ros2_control/blob/d0836b7f12b89acb89bde83d4ba4308513b03204/hardware_interface/src/hardware_component.cpp#L247">source</a>) if the error could be handled we manually call the transition functions which would normally be called to this state. Those are:</p><ul>
<li><b>Previous state</b>: <code>active</code><ul>
<li>Deactivate hardware (<a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#aec3a7dd7cbf651783175b5766c8220c8" title="Called on the transistion from the active to the inactive state.">on_deactivate()</a>) -&gt; <code>inactive</code></li>
<li>Clean-Up hardware (<a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a113dab971a250a727d68a0aef28c13e6" title="Called on the transistion from the inactive to the unconfigured state.">on_cleanup()</a>) -&gt; <code>unconfigured</code></li>
</ul>
</li>
<li><b>Previous state</b>: <code>inactive</code><ul>
<li>Deactivate hardware (<a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#aec3a7dd7cbf651783175b5766c8220c8" title="Called on the transistion from the active to the inactive state.">on_deactivate()</a>) -&gt; <code>inactive</code><ul>
<li>call the deactivate function anyway regardless if state was active or inactive. For example if the <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#ad1af9ab693e0a0dad30bac75bc02b462" title="Called on the transistion from the inactive to the active state.">on_activate()</a> function fails on Joint::enableStallguard() the joint will have been enabled, to disable it invoke <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#aec3a7dd7cbf651783175b5766c8220c8" title="Called on the transistion from the active to the inactive state.">on_deactivate()</a>.</li>
</ul>
</li>
<li>Clean-Up hardware (<a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a113dab971a250a727d68a0aef28c13e6" title="Called on the transistion from the inactive to the unconfigured state.">on_cleanup()</a>) -&gt; <code>unconfigured</code></li>
</ul>
</li>
</ul>
<p>In particular the deactivation is important. For example if a joint stalls the <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#afd6356a580850582282adf77e9461a40" title="Reads from the hardware and populates the state interfaces.">read()</a> or <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#ababed9c7c6dc8660f20dc1b4e950c023" title="Writes commands to the hardware from the command interfaces.">write()</a> methods throw an error, which will be handled here and allow the hardware to be deactivated, disableing the joints to allow backdriving.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_state</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn </dd></dl>

</div>
</div>
<a id="a6aa90281abb9010d645ee5b0d5144af6" name="a6aa90281abb9010d645ee5b0d5144af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa90281abb9010d645ee5b0d5144af6">&#9670;&#160;</a></span>on_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn bioscara_hardware_interface::BioscaraHardwareInterface::on_init </td>
          <td>(</td>
          <td class="paramtype">const hardware_interface::HardwareComponentInterfaceParams &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called on initialization to the <code>unconfigured</code> state. </p>
<p>Performs the following checks on the configures joints parsed form the URDF description:</p><ul>
<li>Each joint must have the 3 command interfaces (in this order): 'position', 'velocity', 'home'</li>
<li>Each joint must have the 3 state interfaces (in this order): 'position', 'velocity', 'home'</li>
</ul>
<p>Stores the configuration parameters for each joint in the _joint_cfg map. Each joint must have these parameters:</p><ul>
<li>i2c_address (int, HEX)</li>
<li>reduction (float)</li>
<li>min (float)</li>
<li>max (float)</li>
<li>stall_threshold (int, DEC)</li>
<li>hold_current (int, DEC)</li>
<li>drive_current (int, DEC)</li>
<li>max_acceleration (float)</li>
<li>max_velocity (float)</li>
<li>homing<ul>
<li>speed (float)</li>
<li>threshold (int, DEC)</li>
<li>current (int, DEC)</li>
<li>acceleration (float)</li>
</ul>
</li>
</ul>
<p>Adds each joint to the internal _joints map. Creates a MockJoint object if the use_mock_hardware parameter is 'True' or 'true', or else a hardware Joint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn </dd></dl>
<p>Loop over all joints decribed in the hardware description file, check if they have the position and velocity command and state interface defined and finally add them to the internal _joints list</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>threshold and current are uint8_t, if a number larger outside 0 &lt; n &lt; 255 is passed as a parameters it will overflow. </dd></dl>

</div>
</div>
<a id="af6b03c347e879fa429abec6a717f24e9" name="af6b03c347e879fa429abec6a717f24e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b03c347e879fa429abec6a717f24e9">&#9670;&#160;</a></span>on_shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::CallbackReturn bioscara_hardware_interface::BioscaraHardwareInterface::on_shutdown </td>
          <td>(</td>
          <td class="paramtype">const rclcpp_lifecycle::State &amp;&#160;</td>
          <td class="paramname"><em>previous_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called on the transistion from the <code>inactive</code>, <code>unconfigured</code> and <code>active</code> to the <code>finalized</code> state. </p>
<p>When transitioning directly from <code>active</code> to <code>finalized</code> <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#aec3a7dd7cbf651783175b5766c8220c8" title="Called on the transistion from the active to the inactive state.">on_deactivate()</a> is automatically called before <a href="https://github.com/ros-controls/ros2_control/blob/d0836b7f12b89acb89bde83d4ba4308513b03204/hardware_interface/src/resource_manager.cpp#L616">Source Code</a> If the previous state is either <code>inactive</code> or <code>active</code> the <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a113dab971a250a727d68a0aef28c13e6" title="Called on the transistion from the inactive to the unconfigured state.">on_cleanup()</a> method is called first. Then regardless of the previous state, the _joints map is cleared. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_state</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::CallbackReturn </dd></dl>

</div>
</div>
<a id="ae217264240bb140ca85381c0d1ca24e4" name="ae217264240bb140ca85381c0d1ca24e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae217264240bb140ca85381c0d1ca24e4">&#9670;&#160;</a></span>prepare_command_mode_switch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::return_type bioscara_hardware_interface::BioscaraHardwareInterface::prepare_command_mode_switch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_interfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>stop_interfaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs checks and book keeping of the active control mode when changing controllers. </p>
<p>For safe operation only one controller may interact with the hardware at the time. For example if the velocity JTC is active and has claimed the velocity command interfaces it is technically possible to activate the position JTC (or a homing controller, or others) that claim a different command interface (position in this case). However if both controllers are active they start writing to the hardware simultaneously which is to be avoided. For this reason a book keeping mechanism has been implemented which stores the currently active command interfaces for each joint in the _joint_command_modes member. Each joint has a set of active command interfaces. When a controller switch is performed the interfaces that should be stopped are removed from each joint set, then the one that should be started are added, if they are already present an error is thrown. Lastly a validation is performed. Currently the validation is simple since each joint may only have one command interface. The validation can be expanded for furture use cases that require a combination of active command interfaces per joint for example. <br  />
 The following basic checks are implemented:</p><ul>
<li><b>On deactivation</b>:<ul>
<li>[ERROR] Homing command interfaces may only be deactivated if no current homing process is ongoing (Joint::getCurrentBCmd() != Joint::HOME)</li>
<li>[WARN] Deactivating a velocity command interface if the velocity set point is 0.0.</li>
<li>[WARN] Deactivating a command interface that has not been started. This should not happen.</li>
</ul>
</li>
<li><b>On activation</b>:<ul>
<li>[ERROR] Activating a command interface that is already started. This should not happen.</li>
<li>[ERROR] Activating a second command interface for a joint.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_interfaces</td><td>command interfaces that should be started in the form "joint/interface" </td></tr>
    <tr><td class="paramname">stop_interfaces</td><td>command interfaces that should be stopped in the form "joint/interface" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::return_type </dd></dl>

</div>
</div>
<a id="afd6356a580850582282adf77e9461a40" name="afd6356a580850582282adf77e9461a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6356a580850582282adf77e9461a40">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::return_type bioscara_hardware_interface::BioscaraHardwareInterface::read </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads from the hardware and populates the state interfaces. </p>
<p>Iterates over all state interfaces and calls the corresponding Joint method.</p>
<ul>
<li>State interface "position" -&gt; Joint::getPosition()</li>
<li>State interface "velocity" -&gt; Joint::getVelocity()</li>
<li>State interface "home" -&gt; Joint::isHomed()<ul>
<li>This does not actually trigger a communication, instead it relies on the return flags of the previous transmissions. Since position and velocity have been called immediatly before the return flags are assumed to be valid.</li>
<li>If the the homing of a joint has been activated through the command interface (Joint::getCurrentBCmd() == Joint::HOME) the device signals BUSY (Joint::isBusy()) as long as it is still homing. <br  />
 If the BUSY flag is reset while the current command is still Joint::HOME we can assume the homing has finished. Then the "home" command interface of the joint is reset to 0.0, which will stop the homing (perform cleanup tasks) at the next write cycle.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td></td></tr>
    <tr><td class="paramname">period</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::return_type </dd></dl>

</div>
</div>
<a id="aceb1efdc164d5c79540f117bf6320bcd" name="aceb1efdc164d5c79540f117bf6320bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb1efdc164d5c79540f117bf6320bcd">&#9670;&#160;</a></span>start_homing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebioscara__hardware__driver.html#afd669880becd2fc4859d33a0f7780231">bioscara_hardware_driver::err_type_t</a> bioscara_hardware_interface::BioscaraHardwareInterface::start_homing </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>velocity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
    <tr><td class="paramname">velocity</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a1edae840470034cfff21117b3270d4f5" name="a1edae840470034cfff21117b3270d4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edae840470034cfff21117b3270d4f5">&#9670;&#160;</a></span>stop_homing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacebioscara__hardware__driver.html#afd669880becd2fc4859d33a0f7780231">bioscara_hardware_driver::err_type_t</a> bioscara_hardware_interface::BioscaraHardwareInterface::stop_homing </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="ababed9c7c6dc8660f20dc1b4e950c023" name="ababed9c7c6dc8660f20dc1b4e950c023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababed9c7c6dc8660f20dc1b4e950c023">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::return_type bioscara_hardware_interface::BioscaraHardwareInterface::write </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes commands to the hardware from the command interfaces. </p>
<p>In contrast to the <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#afd6356a580850582282adf77e9461a40" title="Reads from the hardware and populates the state interfaces.">read()</a> method the <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#ababed9c7c6dc8660f20dc1b4e950c023" title="Writes commands to the hardware from the command interfaces.">write()</a> method only loops over the command interfaces that are currently active defined by the <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a1359775a2b4cfdaa48b41088b10adedb" title="unordered map of sets storing the active command interfaces for each joint.">BioscaraHardwareInterface::_joint_command_modes</a> map. See <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#ae217264240bb140ca85381c0d1ca24e4" title="Performs checks and book keeping of the active control mode when changing controllers.">prepare_command_mode_switch()</a> for a detailed reasoning why this approach has been chosen.</p>
<ul>
<li>Command interface "position" -&gt; Joint::setPosition()</li>
<li>Command interface "velocity" -&gt; Joint::setVelocity()</li>
<li>Command interface "home" -&gt; Joint::startHoming()<ul>
<li>If the commanded value in "home" is != 0.0 the and the joint is currently executing a blocking function, for example homing (Joint::getCurrentBCmd() == Joint::NONE), the homing sequence is started with the speed, sensitivity, current and acceleration defined in the <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#a8af71c4da340c7798ee83f1fcccc1979" title="unordered map storing the configuration struct of the joints.">BioscaraHardwareInterface::_joint_cfg</a> which is polulated from the hardware description urdf. The direction of the homing is determined by the sign of the command interface value.</li>
<li>If the commanded value in "home" is = 0.0 and the joint is currently executing homing, the homing is stopped. This can either happen prematurely through user input or when the homing is completed which is registered in <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#afd6356a580850582282adf77e9461a40" title="Reads from the hardware and populates the state interfaces.">read()</a>.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td></td></tr>
    <tr><td class="paramname">period</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::return_type </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8af71c4da340c7798ee83f1fcccc1979" name="a8af71c4da340c7798ee83f1fcccc1979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af71c4da340c7798ee83f1fcccc1979">&#9670;&#160;</a></span>_joint_cfg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, <a class="el" href="structbioscara__hardware__interface_1_1BioscaraHardwareInterface_1_1joint__config__t.html">joint_config_t</a>&gt; bioscara_hardware_interface::BioscaraHardwareInterface::_joint_cfg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unordered map storing the configuration struct of the joints. </p>
<p>An unordered map is chosen to simplify acces via the joint name, as this conforms well with the ROS2_control hardware interface The map does not need to be ordered. Search, insertion, and removal of elements have average constant-time complexity. </p>

</div>
</div>
<a id="a1359775a2b4cfdaa48b41088b10adedb" name="a1359775a2b4cfdaa48b41088b10adedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1359775a2b4cfdaa48b41088b10adedb">&#9670;&#160;</a></span>_joint_command_modes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, std::set&lt;std::string&gt; &gt; bioscara_hardware_interface::BioscaraHardwareInterface::_joint_command_modes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unordered map of sets storing the active command interfaces for each joint. </p>
<p>Each joint can have a set of active command interfaces. This type of structure is chosen to group interfaces by joint. In the <a class="el" href="classbioscara__hardware__interface_1_1BioscaraHardwareInterface.html#ababed9c7c6dc8660f20dc1b4e950c023" title="Writes commands to the hardware from the command interfaces.">write()</a> function the interface name can simply be constructed by concatenating joint name with interface name. Although currently only one active command interface is allowed at the time, a set can be used to store multiple command interfaces that are acceptable to be combined, for example it would be acceptable to set velocity and driver current and hence that would be an allowable combination.</p>
<p>An unordered map is chosen to simplify acces via the joint name, as this conforms well with the ROS2_control hardware interface. The map does not need to be ordered. Search, insertion, and removal of elements have average constant-time complexity. </p>

</div>
</div>
<a id="a8cf66b54b657b09db178d26e334ed3f5" name="a8cf66b54b657b09db178d26e334ed3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf66b54b657b09db178d26e334ed3f5">&#9670;&#160;</a></span>_joints</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, std::unique_ptr&lt;<a class="el" href="classbioscara__hardware__driver_1_1BaseJoint.html">bioscara_hardware_driver::BaseJoint</a>&gt; &gt; bioscara_hardware_interface::BioscaraHardwareInterface::_joints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unordered map storing the pointers to BaseJoint objects. This will either be a MockJoint or Joint. </p>
<p>An unordered map is chosen to simplify acces via the joint name, as this conforms well with the ROS2_control hardware interface The map does not need to be ordered. Search, insertion, and removal of elements have average constant-time complexity.</p>
<p>Since the BaseJoint methods are implemented as virtual, dynamic method dispatch can be utilized to call the correct implementation of a method. So either BaseJoint::foo() or Joint::foo()/MockJoint::foo() if foo() is overwritten in Joint or MockJoint. a smart pointer is used to guarantee destruction when the pointer is destructed. A unique pointer is used to prevent copying of the object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ROS2/ros2_scara_ws/src/dalsa_bioscara/bioscara_hardware_interface/include/bioscara_hardware_interface/<a class="el" href="bioscara__hardware_8hpp_source.html">bioscara_hardware.hpp</a></li>
<li>ROS2/ros2_scara_ws/src/dalsa_bioscara/bioscara_hardware_interface/src/<a class="el" href="bioscara__hardware_8cpp.html">bioscara_hardware.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
